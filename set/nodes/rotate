#! /usr/bin/env python
# -*- encoding: utf-8 -*-

import time
import rospy
import Jetson.GPIO as GPIO

from std_msgs.msg import String
from sensor_msgs.msg import Imu
from geometry_msgs.msg import Twist
from tf.transformations import euler_from_quaternion

# 초음파 센서 핀 번호
Trig = 21
Echo = 19

# 젯슨나노 GPIO 설정
GPIO.setmode(GPIO.BOARD)
GPIO.setwarnings(False)
GPIO.setup(Trig, GPIO.OUT)
GPIO.setup(Echo, GPIO.IN)


class RotateRobot:
    def __init__(self):
        self.current_yaw = None
        self.target_yaw = None
        self.rotation_speed = 0.7
        self.cmd_vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size=10)
        self.ultra_pub = rospy.Publisher("ultra", String, queue_size=1)

        rospy.Subscriber('/imu/data', Imu, self.imu_callback)
        rospy.Subscriber('/ultra', String, self.ultra_callback)

        self.rate = rospy.Rate(10)

    def imu_callback(self, msg):
        orientation = msg.orientation
        quaternion = [orientation.x, orientation.y,
                      orientation.z, orientation.w]
        roll, pitch, yaw = euler_from_quaternion(quaternion)
        self.current_yaw = yaw

    def rotate(self, rotation):
        if rotation == "l":
            # 목표 yaw 각도 설정
            self.target_yaw = self.current_yaw + 1.57  # 90도 = 1.57rad
        elif rotation == "r":
            # 목표 yaw 각도 설정
            self.target_yaw = self.current_yaw - 1.57  # 90도 = 1.57rad

        # 목표 yaw 각도 될 때까지 회전
        while abs(self.target_yaw - self.current_yaw) > 0.1:
            print(abs(self.target_yaw - self.current_yaw))
            cmd_vel_msg = Twist()
            if self.target_yaw > self.current_yaw:
                cmd_vel_msg.angular.z = self.rotation_speed

            elif self.target_yaw < self.current_yaw:
                cmd_vel_msg.angular.z = -self.rotation_speed

            self.cmd_vel_pub.publish(cmd_vel_msg)
            self.rate.sleep()
        # 회전이 끝나면 로봇 정지
        cmd_vel_msg = Twist()
        cmd_vel_msg.angular.z = 0.0
        self.cmd_vel_pub.publish(cmd_vel_msg)

    def ultra(self, direction):
        while not rospy.is_shutdown():
            GPIO.output(Trig, False)
            time.sleep(0.1)
            GPIO.output(Trig, True)
            time.sleep(0.00001)  # 10us
            GPIO.output(Trig, False)

            while GPIO.input(Echo) == 0:
                start = time.time()

            while GPIO.input(Echo) == 1:
                end = time.time()

            duration = end - start
            distance = duration * 17000
            distance = round(distance, 2)

            print("distance: %fcm\r" % distance)

            cmd_vel_msg = Twist()

            if direction == "f":
                cmd_vel_msg.linear.x = 0.1

                # 5cm까지 전진
                if (distance > 5):
                    self.cmd_vel_pub.publish(cmd_vel_msg)

                else:
                    cmd_vel_msg.linear.x = 0.0
                    self.cmd_vel_pub.publish(cmd_vel_msg)
                    break
            else:
                cmd_vel_msg.linear.x = -0.1

                # 15cm까지 후진
                if (distance < 15):
                    self.cmd_vel_pub.publish(cmd_vel_msg)

                else:
                    cmd_vel_msg.linear.x = 0.0
                    self.cmd_vel_pub.publish(cmd_vel_msg)
                    break

    def ultra_callback(self, msg):
        # 좌회전 후 전진
        if msg.data == "leftFront":
            self.rotate("l")
            self.ultra("f")
            self.ultra_pub.publish("end")
        # 우회전 후 전진
        elif msg.data == "rightFront":
            self.rotate("r")
            self.ultra("f")
            self.ultra_pub.publish("end")
        # 후진 후 좌회전
        elif msg.data == "backLeft":
            self.ultra("b")
            self.rotate("r")
            self.ultra_pub.publish("end")
        # 후진 후 우회전
        elif msg.data == "backRight":
            self.ultra("b")
            self.rotate("r")
            self.ultra_pub.publish("end")
        else:
            pass


if __name__ == '__main__':
    rospy.init_node('rotate_move')
    rospy.loginfo("Ultra on")

    l = RotateRobot()

    try:
        rospy.spin()
    except KeyboardInterrupt:
        print("Shutting down")
