#! /usr/bin/env python
# -*- encoding: utf-8 -*-

import time
import rospy
import Jetson.GPIO as GPIO

from std_msgs.msg import String
from sensor_msgs.msg import Imu
from geometry_msgs.msg import Twist
from tf.transformations import euler_from_quaternion

# 초음파 센서 핀 번호
Trig = 21
Echo = 19

# 젯슨나노 GPIO 설정
GPIO.setmode(GPIO.BOARD)
GPIO.setwarnings(False)
GPIO.setup(Trig, GPIO.OUT)
GPIO.setup(Echo, GPIO.IN)


class RotateRobot:
    def __init__(self):
        self.current_yaw = None
        self.target_yaw = None
        self.rotation_speed = 0.7
        self.cmd_vel_pub = rospy.Publisher('cmd_vel', Twist, queue_size=10)
        self.ultra_pub = rospy.Publisher("ultra", String, queue_size=1)

        rospy.Subscriber('/imu/data', Imu, self.imu_callback)
        rospy.Subscriber('/ultra', String, self.ultra_callback)

        self.rate = rospy.Rate(10)

    def imu_callback(self, msg):
        orientation = msg.orientation
        quaternion = [orientation.x, orientation.y,
                      orientation.z, orientation.w]
        roll, pitch, yaw = euler_from_quaternion(quaternion)
        self.current_yaw = yaw

    def rotate(self, rotation):
        if rotation == "l":
            # 목표 yaw 각도 설정
            self.target_yaw = self.current_yaw + 1.5 
        elif rotation == "r":
            # 목표 yaw 각도 설정
            self.target_yaw = self.current_yaw - 1.5 

        # 목표 yaw 각도 될 때까지 회전
        while abs(self.target_yaw - self.current_yaw) >= 0.1:
            rospy.loginfo("목표 도달까지의 yaw: %.2f" % abs(self.target_yaw - self.current_yaw))
            cmd_vel_msg = Twist()
            if self.target_yaw > self.current_yaw:
                cmd_vel_msg.angular.z = self.rotation_speed

            elif self.target_yaw < self.current_yaw:
                cmd_vel_msg.angular.z = -self.rotation_speed

            self.cmd_vel_pub.publish(cmd_vel_msg)
            self.rate.sleep()
        # 회전이 끝나면 로봇 정지
        cmd_vel_msg = Twist()
        cmd_vel_msg.angular.z = 0.0
        self.cmd_vel_pub.publish(cmd_vel_msg)
        
    def rotate_time(self):
        cmd_vel_msg = Twist()
        cmd_vel_msg.angular.z = self.rotation_speed
        
        for _ in range(30):
            self.cmd_vel_pub.publish(cmd_vel_msg)
            self.rate.sleep()
            
        cmd_vel_msg = Twist()
        cmd_vel_msg.angular.z = 0.0
        self.cmd_vel_pub.publish(cmd_vel_msg)

    def ultra(self, direction):
        while not rospy.is_shutdown():
            GPIO.output(Trig, False)
            time.sleep(0.1)
            GPIO.output(Trig, True)
            time.sleep(0.00001)  # 10us
            GPIO.output(Trig, False)

            while GPIO.input(Echo) == 0:
                start = time.time()

            while GPIO.input(Echo) == 1:
                end = time.time()

            duration = end - start
            distance = duration * 17000
            distance = round(distance, 2)

            rospy.loginfo("전방 물체와의 거리: %fcm" % distance)

            cmd_vel_msg = Twist()

            if direction == "f":
                cmd_vel_msg.linear.x = 0.1

                # 7cm까지 전진
                if (distance > 7):
                    self.cmd_vel_pub.publish(cmd_vel_msg)

                else:
                    cmd_vel_msg.linear.x = 0.0
                    self.cmd_vel_pub.publish(cmd_vel_msg)
                    break
            else:
                cmd_vel_msg.linear.x = -0.1

                # 25cm까지 후진
                if (distance < 25):
                    self.cmd_vel_pub.publish(cmd_vel_msg)

                else:
                    cmd_vel_msg.linear.x = 0.0
                    self.cmd_vel_pub.publish(cmd_vel_msg)
                    break

    def ultra_callback(self, msg):
        if msg.data == "leftFront":
            self.rotate("l")
            time.sleep(2)
            self.ultra("f")
            self.ultra_pub.publish("end")

        elif msg.data == "backLeft":
            self.ultra("b")
            time.sleep(2)
            self.rotate_time()
            self.ultra_pub.publish("end")
            
        elif msg.data == "turn":
            self.rotate_time()
            
        else:
            pass


if __name__ == '__main__':
    rospy.init_node('rotate_move')
    rospy.loginfo("Ultra on")

    l = RotateRobot()

    try:
        rospy.spin()
    except KeyboardInterrupt:
        print("Shutting down")