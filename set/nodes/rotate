#! /usr/bin/env python

import time
import rospy
import Jetson.GPIO as GPIO

from std_msgs.msg import String
from sensor_msgs.msg import Imu
from geometry_msgs.msg import Twist
from tf.transformations import euler_from_quaternion

# Ultrasensor pin number
Trig = 21
Echo = 19

# Jetson nano GPIO settings
GPIO.setmode(GPIO.BOARD)
GPIO.setwarnings(False)
GPIO.setup(Trig, GPIO.OUT)
GPIO.setup(Echo, GPIO.IN)

class RotateRobot:
    def __init__(self):
        rospy.init_node('rotate_move')
        self.current_yaw = None
        self.target_yaw = None
        self.rotation_speed = 0.7
        self.cmd_vel_pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
        
        rospy.Subscriber('/imu/data', Imu, self.imu_callback)
        rospy.Subscriber('/ultra', String, self.ultra_callback)
        
        self.rate = rospy.Rate(10)

    # Save current yaw
    def imu_callback(self, msg):
        # Get current yaw from IMU message
        orientation = msg.orientation
        quaternion = [orientation.x, orientation.y, orientation.z, orientation.w]
        roll, pitch, yaw = euler_from_quaternion(quaternion)
        self.current_yaw = yaw

    # Rotate robot
    def rotate(self, rotation):
        if rotation == "l":
            # Set the target yaw angle direction
            self.target_yaw = self.current_yaw + 1.57 # 90 degrees in radians
        elif rotation == "r":
            # Set the target yaw angle direction
            self.target_yaw = self.current_yaw - 1.57 # 90 degrees in radians
            
        # Rotate the robot until the target yaw angle is reached
        while abs(self.target_yaw - self.current_yaw) > 0.1:
            print(abs(self.target_yaw - self.current_yaw))
            # Publish the rotation speed
            cmd_vel_msg = Twist()
            if self.target_yaw > self.current_yaw:
                cmd_vel_msg.angular.z = self.rotation_speed
                
            elif self.target_yaw < self.current_yaw:
                cmd_vel_msg.angular.z = -self.rotation_speed

            # Publish the rotation command
            self.cmd_vel_pub.publish(cmd_vel_msg)
            self.rate.sleep()
        # Stop the robot
        cmd_vel_msg = Twist()
        cmd_vel_msg.angular.z = 0.0
        self.cmd_vel_pub.publish(cmd_vel_msg)
    # UltraSensor 
    def ultra(self, direction):
        while not rospy.is_shutdown():
            GPIO.output(Trig, False)
            time.sleep(0.1)
            GPIO.output(Trig, True)
            time.sleep(0.00001) # 10us
            GPIO.output(Trig,False)
            
            while GPIO.input(Echo) == 0:
                start = time.time()
                
            while GPIO.input(Echo) == 1:
                end = time.time()
            # Calculate distance
            duration = end - start
            distance = duration * 17000
            distance = round(distance, 2)
            
            print("distance: %fcm\r" % distance)
            
            cmd_vel_msg = Twist()
            
            if direction == "f":
                cmd_vel_msg.linear.x = 0.1
                
                # Move forward until 5 centimeter
                if (distance > 5):
                    self.cmd_vel_pub.publish(cmd_vel_msg)
                    
                else :
                    cmd_vel_msg.linear.x = 0.0
                    self.cmd_vel_pub.publish(cmd_vel_msg)
                    break
            else :
                cmd_vel_msg.linear.x = -0.1
                
                # Move backword until 15 centimeter
                if (distance < 15):
                    self.cmd_vel_pub.publish(cmd_vel_msg) 
                    
                else :
                    cmd_vel_msg.linear.x = 0.0
                    self.cmd_vel_pub.publish(cmd_vel_msg)
                    break
                
    def ultra_callback(self, msg):
        # Turn left and move forward
        if msg.data == "leftFront":
            self.rotate("l")
            self.ultra("f")
        # Turn right and move forward
        if msg.data == "rightFront":
            self.rotate("r")
            self.ultra("f")
        # Move backward and turn left
        if msg.data == "backLeft":
            self.ultra("b")
            self.rotate("r")
        # Move backward and turn right
        if msg.data == "backRight":
            self.ultra("b")
            self.rotate("r")
            

if __name__ == '__main__':
    
    l = RotateRobot()
    
    rospy.loginfo("Ultra on")
    
    rospy.spin()
